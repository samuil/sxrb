module SXRB
  # Objects of Proxy class are part of SXRB DSL and their methods are meant to
  # be used to define set of rules needed to parse XML document. They have no
  # other meaning and should not be used outside of that scope.
  # @api public
  class Proxy
    # Proxy objects are generated by the SXRB itself, and are passed to blocks
    # to be used as DSL. They should not be created in any other context.
    # Implementation might change without prior notice.
    #
    # @api private
    def initialize(callback_tree, current_path = '')
      @callback_tree, @current_path = callback_tree, current_path
    end

    # Defines child (a direct descendant) of an element defined in current block.
    # @param [String] tags
    #   names of tags that should be matched
    #
    # @yield [Proxy]
    #   block receives Proxy element representing matched elements.
    #
    # @return [nil]
    #
    # @api public
    #
    # @todo Add Regexp and other selectors support in addition to Strings.
    def child(*tags, &block)
      define_node(:child, *tags, &block)
    end

    # Defines descendant of an element defined in current block.
    # @param [String] tags
    #   names of tags that should be matched
    #
    # @yield [Proxy]
    #   block receives Proxy element representing matched elements.
    #
    # @return [nil]
    #
    # @api public
    #
    # @todo Add Regexp and other selectors support in addition to strings.
    def descendant(*tags, &block)
      define_node(:descendant, *tags, &block)
    end

    # Defines callback method invoked when matching element is completely
    # parsed.
    #
    # @yield [Node]
    #   block receives whole parsed element with children.
    #
    # @api public
    #
    # @return [nil]
    #
    # @note
    #   `on_element` should not be used for items that are expected to have
    #   large node subtrees.
    def on_element(&block)
      add_callback_on(:element, &block)
    end

    # Defines a callback that is invoked whenever start tag is encountered.
    #
    # @yield [Node]
    #   block receives parsed node without any nested elements. All inline
    #   attributes are available though.
    #
    # @return [nil]
    # @api public
    def on_start(&block)
      add_callback_on(:start, &block)
    end

    # Defines a callback that is invoked whenever anonymous text node within
    # self is encountered.
    #
    # @yield [String]
    #   block receives raw content of parsed data in form of string object.
    #
    # @return [nil]
    #
    # @api public
    def on_characters(&block)
      add_callback_on(:characters, &block)
    end

    # Defines a callback that is invoked whenever end tag is encountered.
    #
    # @yield [Node]
    #   block receives parsed node without any nested elements. All inline
    #   attributes are available though.
    #
    # @return [nil]
    # @api public
    def on_end(&block)
      add_callback_on(:end, &block)
    end
    
    private
    
    def define_node(type, *tags, &block)
      raise ArgumentError unless [:child, :descendant].include?(type)
      
      recursive = { child: false, descendant: true }[type]
      
      tags.each do |tag|
        @callback_tree.add_rule(tag, @current_path, :recursive => recursive).tap do |new_path|
          block.call(Proxy.new(@callback_tree, new_path))
        end
      end
    end
    
    def add_callback_on(callback, &block)
      raise ArgumentError unless [:element, :start, :characters, :end].include?(callback)
      @callback_tree.add_callback(callback, @current_path, &block)
    end
  end
end
